#!/bin/sh

# shebang for coloration, this should only be sourced

if ! [ -f "${CLASH_ROOT-.}"/clash ]; then
  echo 'Could not locate clash'
  exit 1
fi >&2

. "${CLASH_ROOT-.}"/lib/list || exit

dummy_hash() {
  local str="$1"
  local hash_value=0
  local tmp
  local char
  local char_num
  while [ -n "$str" ]; do
    tmp="$str"
    str="${str#?}"
    char="${tmp%$str}"
    char_num="$(printf %d "'$char")"
    hash_value="$((hash_value + char_num))"
  done
  printf '%s\n' "$((hash_value % 8))"
}

class Dict_tuple \
  key            \
  value          \
  _print         \

Dict_tuple_print() {
  printf '('
  if ! "$key"_print 2> /dev/null; then
    printf '%s' "$key"
  fi
  printf ', '
  if ! "$value"_print 2> /dev/null; then
    printf '%s' "$value"
  fi
  printf ')'
}

# Any decent hash function written in shell will be far from fast, we'll keep
# this structure to avoid recomputing the hash function if 2 successive lookups
# are done. This basically just keeps the last key/hash computation.
class Dict_hash_cache \
  stale               \
  key                 \
  hash                \

class Dict       \
  buckets_       \
  hash_function_ \
  last_hashed_   \
  length_        \
  _clear         \
  _get           \
  _hash_function \
  _items         \
  _pretty_print  \
  _remove        \
  _set           \
  __init__       \

Dict_clear() {
  "$buckets_"_foreach del
  "$buckets_"_clear
  "$self"_length__is 0
}

Dict_get() {
  if ! "$("$last_hashed_"_stale)" &&
     [ "$("$last_hashed_"_key; printf x)" = "$1"x ]; then
    local hash_value="$("$last_hashed_"_hash)"
  else
    local hash_value="$("$hash_function_" "$1")"
    "$last_hashed_"_key_is "$1"
    "$last_hashed_"_hash_is "$hash_value"
    "$last_hashed_"_stale_is false
  fi
  local tuple
  local tuple_list
  if tuple_list="$("$self"_node_"$hash_value"_tuple_list_value 2> /dev/null)" &&
    tuple="$("$tuple_list"_find Dict_matching_tuple "$1")"
  then
    local value="$("$tuple"_value; printf x)"
    printf %s "${value%x}"
  else
    printf 'Key not found: %s\n' "$1" >&2
    return 1
  fi
}

Dict_hash_function() {
  if [ "$hash_function_" = "$1" ]; then
    printf 'Nothing to do, hash function already set to: %s\n' "$1" >&2
    return 0
  fi

  if "$buckets_"_is_empty; then
    "$("$self"_last_hashed_)"_stale_is true
    "$self"_hash_function__is "$1"
  else
    echo 'Dict is not empty, cannot change hash function' >&2
    return 1
  fi
}

Dict_items() {
  List "$1"
  "$buckets_"_foreach "$1"_concat
}

Dict_pretty_print() {
  printf '== %s == (nb buckets: %s)\n' "$self" "$("$buckets_"_length_)"

  (
    tuple_printer() {
      printf '%s -> ' "$1"
      "$1"_print
    }
    "$buckets_"_foreach tuple_printer
  )
}

Dict_remove() {
  if ! "$("$last_hashed_"_stale)" &&
     [ "$("$last_hashed_"_key; printf x)" = "$1"x ]; then
    local hash_value="$("$last_hashed_"_hash)"
  else
    local hash_value="$("$hash_function_" "$1")"
    "$last_hashed_"_key_is "$1"
    "$last_hashed_"_hash_is "$hash_value"
    "$last_hashed_"_stale_is false
  fi
  local tuple_list=
  # TODO: need to cleanup bucket if empty (list does not support removal from
  # a node yet, this would require a `remove_node' similarly to `append_node')
  if tuple_list="$("$self"_node_"$hash_value"_tuple_list_value 2> /dev/null)" &&
    "$tuple_list"_remove_if Dict_matching_tuple "$1"
  then
    "$self"_length__is "$((length_ - 1))"
  else
    printf 'Key not found: %s\n' "$1" >&2
    return 1
  fi
}

Dict_set() {
  if [ "$("$self"_get "$1" 2> /dev/null; printf x)" = "$2"x ]; then
    return 0
  fi
  if ! "$("$last_hashed_"_stale)" &&
     [ "$("$last_hashed_"_key; printf x)" = "$1"x ]; then
    local hash_value="$("$last_hashed_"_hash)"
  else
    local hash_value="$("$hash_function_" "$1")"
    "$last_hashed_"_key_is "$1"
    "$last_hashed_"_hash_is "$hash_value"
    "$last_hashed_"_stale_is false
  fi
  local node="$self"_node_"$hash_value" # 3 types tuple_list/{key,value}_$tuple_length
  local tuple_id="$(Dict_tuple_anonymous_id)"
  Dict_tuple "$tuple_id" "$1" "$2"
  "$self"_length__is "$((length_ + 1))"
  # TODO unset path to avoid extra failed execve
  if tuple_list="$("$node"_tuple_list_value 2> /dev/null)"; then
    "$tuple_list"_append "$tuple_id"
  else
    local list_id="$(List_anonymous_id)"
    List "$list_id" "$tuple_id"
    List_node "$node"_tuple_list "$list_id"
    "$buckets_"_append_node_ "$node"_tuple_list
  fi
}

Dict__init__() {
  local hash_cache_id="$(Dict_hash_cache_anonymous_id)"
  Dict_hash_cache "$hash_cache_id" true
  "$self"_last_hashed__is "$hash_cache_id"
  local list_id="$(List_anonymous_id)"
  List "$list_id"
  "$self"_buckets__is "$list_id"
  # no need to use our wrapper here, the dict will always be empty at this point
  "$self"_hash_function__is dummy_hash
  "$self"_length__is 0
}

# "Static" methods
Dict_matching_tuple() {
  [ "$("$2"_key; printf x)" = "$1"x ]
}
