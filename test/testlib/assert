#!/bin/sh

# shebang for coloration, this should only be sourced

condition()
{
  nb_args="$#"
  set -- "$@" "$@"
  index=0
  while [ "$index" -lt "$nb_args" ]; do
    [ "$1" = '--' ] && separator_index="$index"
    index="$((index + 1))"
    shift
  done
  index=0
  while [ "$index" != "$separator_index" ]; do
    set -- "$@" "$1"
    index="$((index + 1))"
    shift
  done
  shift "$(($# - separator_index))"
  "$@" || return # return for set -e
}

assert() {
  condition_retval=0
  condition "$@" || condition_retval="$?" # for set -e
  if [ "$condition_retval" "$assert_operator" 0 ]; then
    return
  fi

  assertion="$*"
  shift "$((separator_index + 1))"
  {
    if [ -t 2 ]; then
      printf '\033[1;31mError\033[0m - '
    else
      printf 'Error - '
    fi
    printf "$@"
    echo
  } >&2
  failed_assertions="$failed_assertions
$assertion
$(printf '\033[1;34m-------------------------------------\033[0m')"
  return 1
}

assert_true() {
  printf '%s -> true\n' "$*"
  assert_operator='='
  assert "$@"
}

assert_false() {
  printf '%s -> false\n' "$*"
  assert_operator='!='
  assert "$@"
}

assert_out() {
  printf '%s\n' "$*"
  out_file="$(mktemp)"
  condition "$@" > "$out_file"
  shift "$((separator_index + 1))"
  output="$(cat "$out_file"; printf x)"
  output="${output%x}"
  rm "$out_file"
  assert_operator='='
  assert [ "$output" = "$*" ] -- 'Output differ'
}

end_tests() {
  printf '\033[1m================ END ================\033[0m\n'
  if [ -z "$failed_assertions" ]; then
    printf '\033[1;32mPASS\033[0m\n'
  else
    printf '%s\n\033[1;31mFAIL\033[0m\n' "$failed_assertions"
    return 1
  fi
}
